import { Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Inject, Input, NgModule, Output, Pipe, Renderer, ViewChildren, forwardRef } from '@angular/core';
import { Subject as Subject$1 } from 'rxjs/Subject';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/do';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableColumn {
    constructor() {
        this.sortable = false;
        this.resizable = false;
        this.visible = true;
        this.styleClassObject = {};
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    getCellColor(row, index) {
        if (this.cellColors !== undefined) {
            return (/** @type {?} */ (this.cellColors))(row.item, row, this, index);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initCellClass();
    }
    /**
     * @return {?}
     */
    _initCellClass() {
        if (!this.styleClass && this.property) {
            if (/^[a-zA-Z0-9_]+$/.test(this.property)) {
                this.styleClass = 'column-' + this.property;
            }
            else {
                this.styleClass = 'column-' + this.property.replace(/[^a-zA-Z0-9_]/g, '');
            }
        }
        if (this.styleClass != null) {
            this.styleClassObject = {
                [this.styleClass]: true
            };
        }
    }
}
DataTableColumn.decorators = [
    { type: Directive, args: [{
                selector: 'data-table-column'
            },] },
];
/** @nocollapse */
DataTableColumn.ctorParameters = () => [];
DataTableColumn.propDecorators = {
    "header": [{ type: Input },],
    "sortable": [{ type: Input },],
    "resizable": [{ type: Input },],
    "property": [{ type: Input },],
    "styleClass": [{ type: Input },],
    "cellColors": [{ type: Input },],
    "width": [{ type: Input },],
    "visible": [{ type: Input },],
    "cellTemplate": [{ type: ContentChild, args: ['dataTableCell',] },],
    "headerTemplate": [{ type: ContentChild, args: ['dataTableHeader',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ROW_TEMPLATE = `
<tr	class="data-table-row"
    [title]="getTooltip()"
    [style.background-color]="dataTable.getRowColor(item, index, _this)"
    [class.row-odd]="index % 2 === 0"
    [class.row-even]="index % 2 === 1"
    [class.selected]="selected"
    [class.clickable]="dataTable.selectOnRowClick"
    (dblclick)="dataTable.rowDoubleClicked(_this, $event)"
    (click)="dataTable.rowClicked(_this, $event)"
    >
    <td [hide]="!dataTable.expandColumnVisible">
        <div tabindex="0" role="button" (click)="expanded = !expanded; $event.stopPropagation()" class="row-expand-button"
            [attr.aria-expanded]="expanded" [title]="dataTable.translations.expandRow" [attr.aria-label]="dataTable.translations.expandRow">
            <i [ngClass]="{'fa-caret-right': !expanded, 'fa-caret-down': expanded}" class="fa fa-lg" aria-hidden="true"></i>
        </div>
    </td>
    <td [hide]="!dataTable.indexColumnVisible" class="index-column" [textContent]="displayIndex"></td>
    <td [hide]="!dataTable.selectColumnVisible" class="select-column">
        <input type="checkbox" [(ngModel)]="selected"/>
    </td>
    <td *ngFor="let column of dataTable.columns" [hide]="!column.visible" [ngClass]="column.styleClassObject" class="data-column"
        [style.background-color]="column.getCellColor(_this, index)">
        <div *ngIf="!column.cellTemplate" [textContent]="item[column.property]"></div>
        <div *ngIf="column.cellTemplate" [ngTemplateOutlet]="column.cellTemplate" [ngTemplateOutletContext]="{column: column, row: _this, item: item}"></div>
    </td>
</tr>
<tr *ngIf="dataTable.expandableRows" [hide]="!expanded" class="row-expansion">
    <td [attr.colspan]="dataTable.columnCount">
        <div [ngTemplateOutlet]="dataTable.expandTemplate" [ngTemplateOutletContext]="{row: _this, item: item}"></div>
    </td>
</tr>
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ROW_STYLE = `
.select-column {
    text-align: center;
}

.row-expand-button {
    cursor: pointer;
    text-align: center;
}

.clickable {
    cursor: pointer;
}
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableRow {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
        this._this = this;
        this.selectedChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    set selected(selected) {
        this._selected = selected;
        this.selectedChange.emit(selected);
    }
    /**
     * @return {?}
     */
    get displayIndex() {
        if (this.dataTable.pagination) {
            return /** @type {?} */ ((this.dataTable.displayParams.offset)) + this.index + 1;
        }
        else {
            return this.index + 1;
        }
    }
    /**
     * @return {?}
     */
    getTooltip() {
        if (this.dataTable.rowTooltip) {
            return this.dataTable.rowTooltip(this.item, this, this.index);
        }
        return '';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.selected = false;
    }
}
DataTableRow.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: '[dataTableRow]',
                template: ROW_TEMPLATE,
                styles: [ROW_STYLE]
            },] },
];
/** @nocollapse */
DataTableRow.ctorParameters = () => [
    { type: DataTable, decorators: [{ type: Inject, args: [forwardRef(() => DataTable),] },] },
];
DataTableRow.propDecorators = {
    "item": [{ type: Input },],
    "index": [{ type: Input },],
    "selectedChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const defaultTranslations = {
    headerReload: 'reload',
    headerColumnSelector: 'column selector',
    indexColumn: 'index',
    selectColumn: 'select',
    selectRow: 'select',
    selectAllRows: 'select',
    expandColumn: 'expand',
    expandRow: 'expand',
    paginationLimit: 'Limit',
    paginationRange: 'Results'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} event
 * @param {?} __1
 * @return {?}
 */
function drag(event, { move: move, up: up }) {
    let /** @type {?} */ startX = event.pageX;
    let /** @type {?} */ startY = event.pageY;
    let /** @type {?} */ x = startX;
    let /** @type {?} */ y = startY;
    let /** @type {?} */ moved = false;
    /**
     * @param {?} event
     * @return {?}
     */
    function mouseMoveHandler(event) {
        let /** @type {?} */ dx = event.pageX - x;
        let /** @type {?} */ dy = event.pageY - y;
        x = event.pageX;
        y = event.pageY;
        if (dx || dy)
            moved = true;
        move(event, dx, dy, x, y);
        event.preventDefault(); // to avoid text selection
    }
    /**
     * @param {?} event
     * @return {?}
     */
    function mouseUpHandler(event) {
        x = event.pageX;
        y = event.pageY;
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        if (up)
            up(event, x, y, moved);
    }
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const TABLE_TEMPLATE = `
<div class="data-table-wrapper">
    <data-table-header *ngIf="header"></data-table-header>
	
    <div class="data-table-box">
    	<table class="table data-table">
            <thead>
                <tr>
                    <th scope="col" [hide]="!expandColumnVisible" class="expand-column-header">
                    <th scope="col" [hide]="!indexColumnVisible" class="index-column-header">
                        <span [textContent]="indexColumnHeader"></span>
                    </th>
                    <th scope="col" [hide]="!selectColumnVisible" class="select-column-header">
                        <input [hide]="!multiSelect" type="checkbox" [(ngModel)]="selectAllCheckbox" [attr.aria-label]="translations.selectAllRows" />
                    </th>
                    <th scope="col" *ngFor="let column of columns" #th [hide]="!column.visible" 
                    	  (click)="headerClicked(column, $event)" 
                    	  (keydown.enter)="headerClicked(column, $event)" (keydown.space)="headerClicked(column, $event)"
                        [class.sortable]="column.sortable" [class.resizable]="column.resizable"
                        [ngClass]="column.styleClassObject" class="column-header" [style.width]="column.width | px"
                        [attr.aria-sort]="column.sortable ? (column.property === sortBy ? (sortAsc ? 'ascending' : 'descending') : 'none') : null"
                        [attr.tabindex]="column.sortable ? '0' : null">
                        <span *ngIf="!column.headerTemplate" [textContent]="column.header"></span>
                        <span *ngIf="column.headerTemplate" [ngTemplateOutlet]="column.headerTemplate" [ngTemplateOutletContext]="{column: column}"></span>
                        <span class="column-sort-icon" *ngIf="column.sortable">
                             <i [hide]="column.property === sortBy" class="fa fa-sort column-sortable-icon" aria-hidden="true"></i>
                             <i [hide]="column.property !== sortBy" class="fa" [ngClass]="{'fa-sort-asc': sortAsc, 'fa-sort-desc': !sortAsc}" aria-hidden="true"></i>
                        </span>
                        <span *ngIf="column.resizable" class="column-resize-handle" (mousedown)="resizeColumnStart($event, column, th)"></span>
                    </th>
                </tr>
            </thead>
            <tbody *ngFor="let item of items; let index=index" class="data-table-row-wrapper"
                   dataTableRow #row [item]="item" [index]="index" (selectedChange)="onRowSelectChanged(row)">
            </tbody>
            <tbody *ngIf="itemCount === 0 && noDataMessage">
                <tr>
                    <td [attr.colspan]="columnCount">{{ noDataMessage }}</td>
                </tr>
            </tbody>
            <tbody class="substitute-rows" *ngIf="pagination && substituteRows">
                <tr *ngFor="let item of substituteItems, let index = index"
                    [class.row-odd]="(index + items.length) % 2 === 0"
                    [class.row-even]="(index + items.length) % 2 === 1"
                    >
                    <td [hide]="!expandColumnVisible"></td>
                    <td [hide]="!indexColumnVisible">&nbsp;</td>
                    <td [hide]="!selectColumnVisible"></td>
                    <td *ngFor="let column of columns" [hide]="!column.visible">
                </tr>
            </tbody>
        </table>
        <div class="busy" *ngIf="showReloading && reloading">
          <i><i class="fa fa-spin fa-cog fa-2x"></i></i>
        </div>
    </div>

    <data-table-pagination *ngIf="pagination"></data-table-pagination>
</div>
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const TABLE_STYLE = `
/* bootstrap override: */

:host /deep/ .data-table.table > tbody+tbody {
    border-top: none;
}
:host /deep/ .data-table.table td {
    vertical-align: middle;
}

:host /deep/ .data-table > thead > tr > th,
:host /deep/ .data-table > tbody > tr > td {
	overflow: hidden;
}

/* I can't use the bootstrap striped table, because of the expandable rows */
:host /deep/ .row-odd {
    background-color: #F6F6F6;
}
:host /deep/ .row-even {
}

.data-table .substitute-rows > tr:hover,
:host /deep/ .data-table .data-table-row:hover {
    background-color: #ECECEC;
}
/* table itself: */

.data-table {
    box-shadow: 0 0 15px rgb(236, 236, 236);
    table-layout: fixed;
}

/* header cells: */

.column-header {
    position: relative;
}
.expand-column-header {
	width: 50px;
}
.select-column-header {
	width: 50px;
	text-align: center;
}
.index-column-header {
	width: 40px;
}
.column-header.sortable {
    cursor: pointer;
}
.column-header .column-sort-icon {
	float: right;
}
.column-header.resizable .column-sort-icon {
    margin-right: 8px;
}
.column-header .column-sort-icon .column-sortable-icon {
    color: lightgray;
}
.column-header .column-resize-handle {
    position: absolute;
    top: 0;
    right: 0;
    margin: 0;
    padding: 0;
    width: 8px;
    height: 100%;
    cursor: col-resize;
}

/* cover: */
.data-table-box {
	position: relative;
}

.busy {
	position: absolute;
	z-index: 1;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
	background-color: rgba(0, 0, 0, 0.25);
}

.busy > i {
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
}
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTable {
    constructor() {
        this._items = [];
        this.header = true;
        this.pagination = true;
        this.indexColumn = true;
        this.indexColumnHeader = '';
        this.selectColumn = false;
        this.multiSelect = true;
        this.substituteRows = true;
        this.expandableRows = false;
        this.translations = defaultTranslations;
        this.selectOnRowClick = false;
        this.autoReload = true;
        this.showReloading = false;
        this._sortAsc = true;
        this._offset = 0;
        this._limit = 10;
        // Reloading:
        this._reloading = false;
        this.reload = new EventEmitter();
        this._displayParams = /** @type {?} */ ({});
        this.subject$ = new Subject$1();
        // event handlers:
        this.rowClick = new EventEmitter();
        this.rowDoubleClick = new EventEmitter();
        this.headerClick = new EventEmitter();
        this.cellClick = new EventEmitter();
        this.selectedRows = [];
        this._selectAllCheckbox = false;
        this._resizeInProgress = false;
        this.resizeLimit = 30;
        this.stream$ = this.subject$.debounceTime(100);
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._items = items;
        this._onReloadFinished();
    }
    /**
     * @return {?}
     */
    get sortBy() {
        return this._sortBy;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortBy(value) {
        this._sortBy = value;
        this.subject$.next();
    }
    /**
     * @return {?}
     */
    get sortAsc() {
        return this._sortAsc;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortAsc(value) {
        this._sortAsc = value;
        this.subject$.next();
    }
    /**
     * @return {?}
     */
    get offset() {
        return this._offset;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set offset(value) {
        this._offset = value;
        this.subject$.next();
    }
    /**
     * @return {?}
     */
    get limit() {
        return this._limit;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set limit(value) {
        this._limit = value;
        this.subject$.next();
    }
    /**
     * @return {?}
     */
    get page() {
        return Math.floor(this.offset / this.limit) + 1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this.offset = (value - 1) * this.limit;
    }
    /**
     * @return {?}
     */
    get lastPage() {
        return Math.ceil(this.itemCount / this.limit);
    }
    /**
     * @param {?} sortBy
     * @param {?} asc
     * @return {?}
     */
    sort(sortBy, asc) {
        this.sortBy = sortBy;
        this.sortAsc = asc;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initDefaultValues();
        this._initDefaultClickEvents();
        this._updateDisplayParams();
        if (this.autoReload) {
            this.reloadItems();
        }
        this.stream$.subscribe(() => {
            this.reloadItems();
        });
    }
    /**
     * @return {?}
     */
    _initDefaultValues() {
        this.indexColumnVisible = this.indexColumn;
        this.selectColumnVisible = this.selectColumn;
        this.expandColumnVisible = this.expandableRows;
    }
    /**
     * @return {?}
     */
    _initDefaultClickEvents() {
        this.headerClick.subscribe((tableEvent) => this.sortColumn(tableEvent.column));
        if (this.selectOnRowClick) {
            this.rowClick.subscribe((tableEvent) => tableEvent.row.selected = !tableEvent.row.selected);
        }
    }
    /**
     * @return {?}
     */
    get reloading() {
        return this._reloading;
    }
    /**
     * @return {?}
     */
    reloadItems() {
        this._reloading = true;
        this.reload.emit(this._getRemoteParameters());
    }
    /**
     * @return {?}
     */
    _onReloadFinished() {
        this._updateDisplayParams();
        this._selectAllCheckbox = false;
        this._reloading = false;
    }
    /**
     * @return {?}
     */
    get displayParams() {
        return this._displayParams;
    }
    /**
     * @return {?}
     */
    _updateDisplayParams() {
        this._displayParams = {
            sortBy: this.sortBy,
            sortAsc: this.sortAsc,
            offset: this.offset,
            limit: this.limit
        };
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    rowClicked(row, event) {
        this.rowClick.emit({ row, event });
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    rowDoubleClicked(row, event) {
        this.rowDoubleClick.emit({ row, event });
    }
    /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    headerClicked(column, event) {
        if (!this._resizeInProgress) {
            event.preventDefault();
            event.stopPropagation();
            this.headerClick.emit({ column, event });
        }
        else {
            this._resizeInProgress = false; // this is because I can't prevent click from mousup of the drag end
        }
    }
    /**
     * @param {?} column
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    cellClicked(column, row, event) {
        this.cellClick.emit({ row, column, event });
    }
    /**
     * @return {?}
     */
    _getRemoteParameters() {
        let /** @type {?} */ params = /** @type {?} */ ({});
        if (this.sortBy) {
            params.sortBy = this.sortBy;
            params.sortAsc = this.sortAsc;
        }
        if (this.pagination) {
            params.offset = this.offset;
            params.limit = this.limit;
        }
        return params;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    sortColumn(column) {
        if (column.sortable) {
            let /** @type {?} */ ascending = this.sortBy === column.property ? !this.sortAsc : true;
            this.sort(column.property, ascending);
        }
    }
    /**
     * @return {?}
     */
    get columnCount() {
        let /** @type {?} */ count = 0;
        count += this.indexColumnVisible ? 1 : 0;
        count += this.selectColumnVisible ? 1 : 0;
        count += this.expandColumnVisible ? 1 : 0;
        this.columns.toArray().forEach(column => {
            count += column.visible ? 1 : 0;
        });
        return count;
    }
    /**
     * @param {?} item
     * @param {?} index
     * @param {?} row
     * @return {?}
     */
    getRowColor(item, index, row) {
        if (this.rowColors !== undefined) {
            return (/** @type {?} */ (this.rowColors))(item, row, index);
        }
    }
    /**
     * @return {?}
     */
    get selectAllCheckbox() {
        return this._selectAllCheckbox;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectAllCheckbox(value) {
        this._selectAllCheckbox = value;
        this._onSelectAllChanged(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _onSelectAllChanged(value) {
        this.rows.toArray().forEach(row => row.selected = value);
    }
    /**
     * @param {?} row
     * @return {?}
     */
    onRowSelectChanged(row) {
        // maintain the selectedRow(s) view
        if (this.multiSelect) {
            let /** @type {?} */ index = this.selectedRows.indexOf(row);
            if (row.selected && index < 0) {
                this.selectedRows.push(row);
            }
            else if (!row.selected && index >= 0) {
                this.selectedRows.splice(index, 1);
            }
        }
        else {
            if (row.selected) {
                this.selectedRow = row;
            }
            else if (this.selectedRow === row) {
                delete this.selectedRow;
            }
        }
        // unselect all other rows:
        if (row.selected && !this.multiSelect) {
            this.rows.toArray().filter(row_ => row_.selected).forEach(row_ => {
                if (row_ !== row) {
                    // avoid endless loop
                    row_.selected = false;
                }
            });
        }
    }
    /**
     * @return {?}
     */
    get substituteItems() {
        return Array.from({ length: /** @type {?} */ ((this.displayParams.limit)) - this.items.length });
    }
    /**
     * @param {?} event
     * @param {?} column
     * @param {?} columnElement
     * @return {?}
     */
    resizeColumnStart(event, column, columnElement) {
        this._resizeInProgress = true;
        drag(event, {
            move: (moveEvent, dx) => {
                if (this._isResizeInLimit(columnElement, dx)) {
                    column.width = columnElement.offsetWidth + dx;
                }
            },
        });
    }
    /**
     * @param {?} columnElement
     * @param {?} dx
     * @return {?}
     */
    _isResizeInLimit(columnElement, dx) {
        /* This is needed because CSS min-width didn't work on table-layout: fixed.
                 Without the limits, resizing can make the next column disappear completely,
                 and even increase the table width. The current implementation suffers from the fact,
                 that offsetWidth sometimes contains out-of-date values. */
        if ((dx < 0 && (columnElement.offsetWidth + dx) <= this.resizeLimit) ||
            !columnElement.nextElementSibling ||
            // resizing doesn't make sense for the last visible column
            (dx >= 0 && ((/** @type {?} */ (columnElement.nextElementSibling)).offsetWidth + dx) <= this.resizeLimit)) {
            return false;
        }
        return true;
    }
}
DataTable.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: 'data-table',
                template: TABLE_TEMPLATE,
                styles: [TABLE_STYLE]
            },] },
];
/** @nocollapse */
DataTable.ctorParameters = () => [];
DataTable.propDecorators = {
    "items": [{ type: Input },],
    "itemCount": [{ type: Input },],
    "columns": [{ type: ContentChildren, args: [DataTableColumn,] },],
    "rows": [{ type: ViewChildren, args: [DataTableRow,] },],
    "expandTemplate": [{ type: ContentChild, args: ['dataTableExpand',] },],
    "headerTitle": [{ type: Input },],
    "header": [{ type: Input },],
    "pagination": [{ type: Input },],
    "indexColumn": [{ type: Input },],
    "indexColumnHeader": [{ type: Input },],
    "rowColors": [{ type: Input },],
    "rowTooltip": [{ type: Input },],
    "selectColumn": [{ type: Input },],
    "multiSelect": [{ type: Input },],
    "substituteRows": [{ type: Input },],
    "expandableRows": [{ type: Input },],
    "translations": [{ type: Input },],
    "selectOnRowClick": [{ type: Input },],
    "autoReload": [{ type: Input },],
    "showReloading": [{ type: Input },],
    "noDataMessage": [{ type: Input },],
    "sortBy": [{ type: Input },],
    "sortAsc": [{ type: Input },],
    "offset": [{ type: Input },],
    "limit": [{ type: Input },],
    "page": [{ type: Input },],
    "reload": [{ type: Output },],
    "rowClick": [{ type: Output },],
    "rowDoubleClick": [{ type: Output },],
    "headerClick": [{ type: Output },],
    "cellClick": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PAGINATION_TEMPLATE = `
<div class="pagination-box">
    <div class="pagination-range">
        {{dataTable.translations.paginationRange}}:
        <span [textContent]="dataTable.offset + 1"></span>
        -
        <span [textContent]="[dataTable.offset + dataTable.limit , dataTable.itemCount] | min"></span>
        /
        <span [textContent]="dataTable.itemCount"></span>
    </div>
    <div class="pagination-controllers">
        <div class="pagination-limit">
            <div class="input-group">
            	<div class="input-group-prepend">
                	<span class="input-group-text">{{dataTable.translations.paginationLimit}}:</span>
				</div>
                <select class="form-control" [(ngModel)]="limit">
					<option *ngFor="let l of limits" [value]="l">{{l}}</option>
		        </select>
            </div>
        </div>
        <div class=" pagination-pages">
            <button [disabled]="dataTable.offset <= 0" (click)="pageFirst()" class="btn btn-default pagination-firstpage">
                <i class="fa fa-angle-double-left" aria-hidden="true"></i>
			</button>
            <button [disabled]="dataTable.offset <= 0" (click)="pageBack()" class="btn btn-default pagination-prevpage">
            	<i class="fa fa-angle-left" aria-hidden="true"></i>
			</button>
            <div class="pagination-page">
                <div class="input-group">
                    <input #pageInput type="number" class="form-control" min="1" step="1" max="{{maxPage}}"
                           [ngModel]="page" (blur)="page = pageInput.value"
                           (keyup.enter)="page = pageInput.value" (keyup.esc)="pageInput.value = page"/>
                    <div class="input-group-append">
                        <span class="input-group-text">/{{dataTable.lastPage}}</span>
                    </div>
                </div>
            </div>
            <button [disabled]="(dataTable.offset + dataTable.limit) >= dataTable.itemCount" (click)="pageForward()" class="btn btn-default pagination-nextpage">
            	<i class="fa fa-angle-right" aria-hidden="true"></i>
			</button>
            <button [disabled]="(dataTable.offset + dataTable.limit) >= dataTable.itemCount" (click)="pageLast()" class="btn btn-default pagination-lastpage">
                <i class="fa fa-angle-double-right" aria-hidden="true"></i>
			</button>
        </div>
    </div>
</div>
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PAGINATION_STYLE = `
.pagination-box {
    position: relative;
    margin-top: -10px;
}
.pagination-range {
    margin-top: 7px;
    margin-left: 3px;
    display: inline-block;
}
.pagination-controllers {
    float: right;
}
.pagination-controllers select {
    min-width: 60px;
    /*padding: 1px 0px 0px 5px;*/
    text-align: right;
}

.pagination-limit {
    margin-right: 25px;
    display: inline-table;
}
.pagination-pages {
    display: inline-block;
}
.pagination-page {
    width: 125px;
    display: inline-table;
}
.pagination-box button {
    outline: none !important;
}
.pagination-prevpage,
.pagination-nextpage,
.pagination-firstpage,
.pagination-lastpage {
    vertical-align: top;
    cursor: pointer;
}
.pagination-reload {
    color: gray;
    font-size: 12px;
}
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTablePagination {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
        this.limits = [10, 25, 50, 100, 250];
    }
    /**
     * @return {?}
     */
    pageBack() {
        this.dataTable.offset -= Math.min(this.dataTable.limit, this.dataTable.offset);
    }
    /**
     * @return {?}
     */
    pageForward() {
        this.dataTable.offset += this.dataTable.limit;
    }
    /**
     * @return {?}
     */
    pageFirst() {
        this.dataTable.offset = 0;
    }
    /**
     * @return {?}
     */
    pageLast() {
        this.dataTable.offset = (this.maxPage - 1) * this.dataTable.limit;
    }
    /**
     * @return {?}
     */
    get maxPage() {
        return Math.ceil(this.dataTable.itemCount / this.dataTable.limit);
    }
    /**
     * @return {?}
     */
    get limit() {
        return this.dataTable.limit;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set limit(value) {
        this.dataTable.limit = Number(/** @type {?} */ (value)); // TODO better way to handle that value of number <input> is string?
    }
    /**
     * @return {?}
     */
    get page() {
        return this.dataTable.page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this.dataTable.page = Number(/** @type {?} */ (value));
    }
}
DataTablePagination.decorators = [
    { type: Component, args: [{
                moduleId: module.id,
                selector: 'data-table-pagination',
                template: PAGINATION_TEMPLATE,
                styles: [PAGINATION_STYLE]
            },] },
];
/** @nocollapse */
DataTablePagination.ctorParameters = () => [
    { type: DataTable, decorators: [{ type: Inject, args: [forwardRef(() => DataTable),] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const HEADER_TEMPLATE = `
<div class="data-table-header">
    <h4 class="title" [textContent]="dataTable.headerTitle"></h4>
    <div class="button-panel">
        <button type="button" class="btn btn-default btn-sm refresh-button"
            (click)="dataTable.reloadItems()" 
            [attr.aria-label]="dataTable.translations.headerReload" [title]="dataTable.translations.headerReload">
            <i class="fa fa-refresh" aria-hidden="true"></i>
        </button>
        <button type="button" class="btn btn-default btn-sm column-selector-button" [class.active]="columnSelectorOpen"
            (click)="columnSelectorOpen = !columnSelectorOpen; $event.stopPropagation()" 
            [attr.aria-label]="dataTable.translations.headerColumnSelector" [title]="dataTable.translations.headerColumnSelector">
            <i class="fa fa-list" aria-hidden="true"></i>
        </button>
        <div class="column-selector-wrapper" (click)="$event.stopPropagation()">
            <div *ngIf="columnSelectorOpen" class="column-selector-box panel panel-default">
                <div *ngIf="dataTable.expandableRows" class="column-selector-fixed-column checkbox">
                    <label>
                        <input type="checkbox" [(ngModel)]="dataTable.expandColumnVisible"/>
                        <span>{{dataTable.translations.expandColumn}}</span>
                    </label>
                </div>
                <div *ngIf="dataTable.indexColumn" class="column-selector-fixed-column checkbox">
                    <label>
                        <input type="checkbox" [(ngModel)]="dataTable.indexColumnVisible"/>
                        <span>{{dataTable.translations.indexColumn}}</span>
                    </label>
                </div>
                <div *ngIf="dataTable.selectColumn" class="column-selector-fixed-column checkbox">
                    <label>
                        <input type="checkbox" [(ngModel)]="dataTable.selectColumnVisible"/>
                        <span>{{dataTable.translations.selectColumn}}</span>
                    </label>
                </div>
                <div *ngFor="let column of dataTable.columns" class="column-selector-column checkbox">
                    <label>
                        <input type="checkbox" [(ngModel)]="column.visible"/>
                        <span [textContent]="column.header"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>
</div>
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const HEADER_STYLE = `
.data-table-header {
    min-height: 25px;
    margin-bottom: 10px;
}
.title {
    display: inline-block;
    margin: 5px 0 0 5px;
}
.button-panel {
    float: right;
}
.button-panel button {
    outline: none !important;
}

.column-selector-wrapper {
    position: relative;
}
.column-selector-box {
    box-shadow: 0 0 10px lightgray;
    background: white;
    width: 150px;
    padding: 10px;
    position: absolute;
    right: 0;
    top: 1px;
    z-index: 1060;
}
.column-selector-box .checkbox {
    margin-bottom: 4px;
}
.column-selector-fixed-column {
    font-style: italic;
}
`;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableHeader {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
        this.columnSelectorOpen = false;
    }
    /**
     * @return {?}
     */
    _closeSelector() {
        this.columnSelectorOpen = false;
    }
}
DataTableHeader.decorators = [
    { type: Component, args: [{
                selector: 'data-table-header',
                template: HEADER_TEMPLATE,
                styles: [HEADER_STYLE],
                host: {
                    '(document:click)': '_closeSelector()'
                }
            },] },
];
/** @nocollapse */
DataTableHeader.ctorParameters = () => [
    { type: DataTable, decorators: [{ type: Inject, args: [forwardRef(() => DataTable),] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableResource {
    /**
     * @param {?} items
     */
    constructor(items) {
        this.items = items;
    }
    /**
     * @param {?} params
     * @param {?=} filter
     * @return {?}
     */
    query(params, filter) {
        let /** @type {?} */ result = [];
        if (filter) {
            result = this.items.filter(filter);
        }
        else {
            result = this.items.slice(); // shallow copy to use for sorting instead of changing the original
        }
        if (params.sortBy) {
            result.sort((a, b) => {
                if (typeof a[/** @type {?} */ ((params.sortBy))] === 'string') {
                    return a[/** @type {?} */ ((params.sortBy))].localeCompare(b[/** @type {?} */ ((params.sortBy))]);
                }
                else {
                    return a[/** @type {?} */ ((params.sortBy))] - b[/** @type {?} */ ((params.sortBy))];
                }
            });
            if (params.sortAsc === false) {
                result.reverse();
            }
        }
        if (params.offset !== undefined) {
            if (params.limit === undefined) {
                result = result.slice(params.offset, result.length);
            }
            else {
                result = result.slice(params.offset, params.offset + params.limit);
            }
        }
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(result));
        });
    }
    /**
     * @return {?}
     */
    count() {
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(this.items.length));
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isBlank(obj) {
    return obj === undefined || obj === null;
}
class Hide {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     */
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._prevCondition = false;
    }
    /**
     * @param {?} newCondition
     * @return {?}
     */
    set hide(newCondition) {
        this.initDisplayStyle();
        if (newCondition && (isBlank(this._prevCondition) || !this._prevCondition)) {
            this._prevCondition = true;
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'display', 'none');
        }
        else if (!newCondition && (isBlank(this._prevCondition) || this._prevCondition)) {
            this._prevCondition = false;
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'display', this._displayStyle);
        }
    }
    /**
     * @return {?}
     */
    initDisplayStyle() {
        if (this._displayStyle === undefined) {
            let /** @type {?} */ displayStyle = this._elementRef.nativeElement.style.display;
            if (displayStyle && displayStyle !== 'none') {
                this._displayStyle = displayStyle;
            }
        }
    }
}
Hide.decorators = [
    { type: Directive, args: [{ selector: '[hide]', inputs: ['hide'] },] },
];
/** @nocollapse */
Hide.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MinPipe {
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    transform(value, args) {
        return Math.min.apply(null, value);
    }
}
MinPipe.decorators = [
    { type: Pipe, args: [{
                name: 'min'
            },] },
];
/** @nocollapse */
MinPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PixelConverter {
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    transform(value, args) {
        if (value === undefined) {
            return;
        }
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'number') {
            return value + 'px';
        }
    }
}
PixelConverter.decorators = [
    { type: Pipe, args: [{
                name: 'px'
            },] },
];
/** @nocollapse */
PixelConverter.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableModule {
}
DataTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DataTable, DataTableColumn,
                    DataTableRow, DataTablePagination, DataTableHeader,
                    PixelConverter, Hide, MinPipe
                ],
                imports: [CommonModule, FormsModule],
                exports: [
                    DataTable, DataTableColumn
                ]
            },] },
];
/** @nocollapse */
DataTableModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Public classes.
const DATA_TABLE_DIRECTIVES = [DataTable, DataTableColumn];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Angular 5 Data Table
 * Build an Angular library compatible with AoT compilation & Tree shaking
 * Copyright Bruno Bruzzano
 * MIT license
 * https://github.com/brunano21/angular-4-data-table
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { DataTableModule, DataTable, DataTableColumn, DataTableRow, DataTablePagination, DataTableResource, DataTableHeader, defaultTranslations, DATA_TABLE_DIRECTIVES, HEADER_STYLE as ɵh, HEADER_TEMPLATE as ɵg, PAGINATION_STYLE as ɵf, PAGINATION_TEMPLATE as ɵe, ROW_STYLE as ɵd, ROW_TEMPLATE as ɵc, TABLE_STYLE as ɵb, TABLE_TEMPLATE as ɵa, Hide as ɵj, MinPipe as ɵk, PixelConverter as ɵi };
//# sourceMappingURL=angular5-data-table.js.map
